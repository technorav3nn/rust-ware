use std::{
    process::{Child, Command},
    sync::Mutex,
};

use serde::{Deserialize, Serialize};
use sysinfo::{Pid, PidExt, ProcessExt, System, SystemExt};

lazy_static! {
    #[allow(non_upper_case_globals)]
    static ref sys_info: Mutex<System> = {
        let unsafe_sys_info = System::new_all();
        Mutex::new(unsafe_sys_info)
    };
}

pub struct Injector {
    pid: u32,
}

impl Injector {
    pub fn inject(pid: usize, args: Vec<String>) -> Result<Child, std::io::Error> {
        let mut sys = sys_info.lock().unwrap();
        sys.refresh_processes();

        match sys.process(Pid::from(pid)) {
            Some(process) => {
                process.kill();
                let child = Command::new("/Applications/Roblox.app/Contents/MacOS/RobloxPlayer")
                    .args(args)
                    .spawn()?;

                Ok(child)
            }
            None => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Process not found!",
            )),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Process {
    pub pid: u32,
    pub command: String,
    pub arguments: Vec<String>,
}

/// Gets all the Roblox processes running on the system.
/// Returns a vector of  `Process`es.
pub fn get_roblox_processes() -> Vec<Process> {
    let mut result: Vec<Process> = Vec::new();

    let mut sys = sys_info.lock().unwrap();

    sys.refresh_processes();

    for process in sys.processes_by_name("RobloxPlayer") {
        let args = process.cmd().to_vec();
        let filtered_args = args
            .into_iter()
            .filter(|e| return e.find("--crashHandler").is_none());

        // convert the command line args into a full string
        let args_as_string = filtered_args.clone().collect::<Vec<String>>().join(" ");

        result.push(Process {
            pid: process.pid().as_u32(),
            command: args_as_string,
            arguments: filtered_args.collect(),
        });
    }

    result
}
