use std::sync::Mutex;

use base64::{engine::general_purpose, Engine};
use sw_auth::Authenticator;
use tauri::api::process::{Command, Output};

// globals
lazy_static! {
    #[allow(non_upper_case_globals)]
    static ref AUTH: Mutex<Authenticator> = {
        let unsafe_auth = sw_auth::Authenticator::new();
        Mutex::new(unsafe_auth)
    };
}

pub fn authenticate_user(username: &str, password: &str) -> () {
    let enc_username = general_purpose::STANDARD.encode(username.as_bytes());
    let enc_password = general_purpose::STANDARD.encode(password.as_bytes());

    // TODO: Handle 2FA
    let Output { stdout, .. } = Command::new_sidecar("SWMAuth2")
        .expect("failed to create auth")
        .args(&[enc_username, enc_password])
        .output()
        .expect("failed to run auth");

    let auth = AUTH.lock().unwrap();

    match auth.authenticate(stdout) {
        Ok((success, code, token)) => {
            if success {
                println!("Success! Code: {:?}, Token: {}", code, token);
            } else {
                println!("Failure! Code: {:?}", code);
            }
        }
        Err(e) => panic!("Error in auth with code: {:?}", e),
    };
}
